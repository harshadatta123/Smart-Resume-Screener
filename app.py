# app.py
import os
import json
import streamlit as st
from dotenv import load_dotenv
from PyPDF2 import PdfReader
from docx import Document
import google.generativeai as genai
import numpy as np
from sklearn.metrics.pairwise import cosine_similarity
from typing import Dict, Any
from io import BytesIO
import oracledb  # ‚úÖ NEW
import datetime  # for timestamp

# ---------- Load Environment ----------
load_dotenv()
GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")
if not GEMINI_API_KEY:
    st.error("‚ùå GEMINI_API_KEY not found in .env file. Please add it.")
    st.stop()

genai.configure(api_key=GEMINI_API_KEY)

# ---------- ORACLE CONNECTION ----------
try:
    connection = oracledb.connect(
        user="system", password="hero", dsn="localhost:1521/XE"
    )
    cursor = connection.cursor()

    # ‚úÖ Create table if it doesn‚Äôt exist
    cursor.execute("""
    BEGIN
        EXECUTE IMMEDIATE '
        CREATE TABLE shortlisted_candidates (
            id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            name VARCHAR2(200),
            email VARCHAR2(200),
            phone VARCHAR2(50),
            skills CLOB,
            match_percent NUMBER,
            justification CLOB,
            filename VARCHAR2(200),
            uploaded_on TIMESTAMP
        )';
    EXCEPTION
        WHEN OTHERS THEN
            IF SQLCODE != -955 THEN
                RAISE;
            END IF;
    END;
    """)
    connection.commit()
except Exception as e:
    st.error(f"Database connection failed: {e}")
    st.stop()

# ---------- Streamlit UI ----------
st.set_page_config(page_title="Resume Scanner (Gemini)", layout="wide")
st.title("Resume Scanner ‚Äî Powered by Gemini Pro ‚ö°")
st.caption("Upload resumes and compare them with a Job Description. Top candidates are saved in Oracle DB.")

# ---------- File Reading Utilities ----------
def extract_text_from_pdf_bytes(file_bytes) -> str:
    file_stream = BytesIO(file_bytes)
    reader = PdfReader(file_stream)
    text = []
    for page in reader.pages:
        try:
            t = page.extract_text() or ""
        except Exception:
            t = ""
        if t:
            text.append(t)
    return "\n\n".join(text)

def extract_text_from_docx(file_bytes) -> str:
    doc = Document(BytesIO(file_bytes))
    return "\n".join([p.text for p in doc.paragraphs])

def extract_text(file) -> str:
    if file.name.lower().endswith(".pdf"):
        return extract_text_from_pdf_bytes(file.getvalue())
    elif file.name.lower().endswith(".txt"):
        return file.getvalue().decode("utf-8", errors="ignore")
    elif file.name.lower().endswith(".docx"):
        return extract_text_from_docx(file.getvalue())
    else:
        raise ValueError("Unsupported file format.")

# ---------- Gemini Helpers ----------
def call_gemini_extract_structured(resume_text: str) -> Dict[str, Any]:
    model = genai.GenerativeModel("gemini-2.0-pro")
    prompt = f"""
    You are a structured data extractor.
    Parse the following resume text and return valid JSON with these fields:
    - name
    - email
    - phone
    - summary
    - skills (list)
    - experience (list of {{title, company, start, end, bullets}})
    - education (list of {{degree, institution, year}})

    Resume text:
    \"\"\"{resume_text[:6000]}\"\"\""""
    response = model.generate_content(prompt)
    content = response.text.strip()
    try:
        first = content.find("{")
        last = content.rfind("}")
        json_text = content[first:last+1]
        parsed = json.loads(json_text)
    except Exception:
        parsed = {
            "name": "",
            "email": "",
            "phone": "",
            "summary": resume_text[:500],
            "skills": [],
            "experience": [],
            "education": [],
        }
    return parsed

def get_gemini_embedding(text: str) -> np.ndarray:
    try:
        embed_model = "models/text-embedding-004"
        result = genai.embed_content(model=embed_model, content=text)
        emb = np.array(result["embedding"], dtype=np.float32)
        return emb
    except Exception:
        return np.random.rand(768)

def cosine_sim(a: np.ndarray, b: np.ndarray) -> float:
    if a is None or b is None:
        return 0.0
    a = a.reshape(1, -1)
    b = b.reshape(1, -1)
    return float(cosine_similarity(a, b)[0][0])

def gemini_score_candidate_against_job(candidate_struct: dict, job_desc: str) -> dict:
    model = genai.GenerativeModel("gemini-2.0-pro")
    skills_text = " ".join([str(s or "") for s in candidate_struct.get("skills", [])])
    exp_text = " ".join([
        f"{str(e.get('title') or '')} {str(e.get('company') or '')}" 
        for e in candidate_struct.get("experience", []) if isinstance(e, dict)
    ])
    summary_text = str(candidate_struct.get("summary") or "")
    candidate_text = " ".join([summary_text, skills_text, exp_text]).strip()
    if not candidate_text:
        candidate_text = "Candidate resume content not available."

    prompt = f"""
You are an expert recruiter. Compare the candidate resume text with the job description.
Candidate resume:
\"\"\"{candidate_text}\"\"\"
Job description:
\"\"\"{job_desc}\"\"\"

Provide output in strict JSON format:
{{
  "match_percent": <integer 0-100>,
  "justification": "<2-3 concise sentences explaining reasoning>"
}}
"""
    response = model.generate_content(prompt)
    text = response.text.strip()
    first = text.find("{")
    last = text.rfind("}")
    if first != -1 and last != -1:
        try:
            parsed = json.loads(text[first:last+1])
            parsed["match_percent"] = int(parsed.get("match_percent", 50))
            parsed["justification"] = str(parsed.get("justification", "No justification provided."))
            return parsed
        except:
            pass
    return {"match_percent": 50, "justification": "Could not compute automatically."}

# ---------- Sidebar ----------
with st.sidebar:
    st.header("Settings")
    top_k = st.number_input("Top K shortlisted candidates", 1, 20, 5)
    weight_embedding = st.slider("Weight for embedding similarity", 0.0, 1.0, 0.6)

# ---------- Show Stored Candidates ----------
st.subheader("üóÇÔ∏è Previously Shortlisted Candidates (from Oracle)")
try:
    cursor.execute("SELECT name, email, phone, skills, match_percent, justification, uploaded_on FROM shortlisted_candidates ORDER BY uploaded_on DESC")
    stored = cursor.fetchall()
    if stored:
        for row in stored:
            name, email, phone, skills, percent, justification, uploaded_on = row
            st.markdown(f"""
            **Name:** {name or 'N/A'}  
            **Email:** {email or 'N/A'}  
            **Phone:** {phone or 'N/A'}  
            **Match:** {percent}%  
            **Skills:** {skills or ''}  
            **Justification:** {justification or ''}  
            **Date:** {uploaded_on}
            ---
            """)
    else:
        st.info("No shortlisted candidates found yet.")
except Exception as e:
    st.error(f"Failed to load stored candidates: {e}")

# ---------- Main Input ----------
uploaded_files = st.file_uploader("Upload resumes", accept_multiple_files=True, type=["pdf", "txt", "docx"])
job_desc = st.text_area("Paste the Job Description", height=200)

# ---------- Main Logic ----------
if st.button("Analyze Resumes"):
    if not uploaded_files or not job_desc.strip():
        st.error("Please upload resumes and enter a job description.")
        st.stop()

    st.info("üîç Processing resumes... please wait.")
    job_emb = get_gemini_embedding(job_desc)
    results = []

    for f in uploaded_files:
        try:
            resume_text = extract_text(f)
            parsed = call_gemini_extract_structured(resume_text)
            skills = parsed.get("skills", [])
            skills_text = " ".join([str(s or "") for s in skills])
            experience = parsed.get("experience", [])
            exp_text = " ".join([
                f"{str(e.get('title') or '')} {str(e.get('company') or '')}"
                for e in experience if isinstance(e, dict)
            ])
            summary_text = str(parsed.get("summary") or "")
            candidate_text = " ".join([summary_text, skills_text, exp_text]).strip()

            cand_emb = get_gemini_embedding(candidate_text)
            sim = cosine_sim(cand_emb, job_emb)
            sim_norm = (sim + 1) / 2
            llm_score = gemini_score_candidate_against_job(parsed, job_desc)
            llm_percent = llm_score.get("match_percent", 50)
            justification = llm_score.get("justification", "")
            final_score = weight_embedding * sim_norm + (1 - weight_embedding) * (llm_percent / 100)
            final_percent = int(round(final_score * 100))

            results.append({
                "filename": f.name,
                "parsed": parsed,
                "final_percent": final_percent,
                "justification": justification
            })

        except Exception as e:
            st.error(f"Error processing {f.name}: {e}")

    results_sorted = sorted(results, key=lambda x: x["final_percent"], reverse=True)
    st.header("üìã Shortlisted Candidates")
    for i, r in enumerate(results_sorted[:top_k], start=1):
        parsed = r["parsed"]
        name = parsed.get("name") or f"Candidate {i}"
        email = parsed.get("email", "")
        phone = parsed.get("phone", "")
        skills = ", ".join(parsed.get("skills", []))
        justification = r["justification"]
        percent = r["final_percent"]

        st.metric(label=f"{i}. {name}", value=f"{percent}%")
        st.write(f"**Email:** {email}")
        st.write(f"**Phone:** {phone}")
        st.write(f"**Skills:** {skills}")
        st.write(f"**Justification:** {justification}")
        st.markdown("---")

        # ‚úÖ Save to Oracle
        try:
            cursor.execute("""
                INSERT INTO shortlisted_candidates
                (name, email, phone, skills, match_percent, justification, filename, uploaded_on)
                VALUES (:1, :2, :3, :4, :5, :6, :7, :8)
            """, (
                name, email, phone, skills, percent, justification, r["filename"], datetime.datetime.now()
            ))
            connection.commit()
        except Exception as e:
            st.warning(f"Could not save {name}: {e}")

    st.success("‚úÖ Resume analysis complete and shortlisted candidates saved!")
    st.balloons()
